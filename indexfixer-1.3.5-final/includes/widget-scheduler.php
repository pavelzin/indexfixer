<?php
/**
 * Ujednolicony mechanizm planowania sprawdzania URL-i dla widget√≥w
 */

if (!defined('ABSPATH')) {
    exit;
}

class IndexFixer_Widget_Scheduler {
    
    private static $instance = null;
    public static $hook_name = 'indexfixer_widget_check'; // Zmieniono na public ≈ºeby by≈Ço dostƒôpne z zewnƒÖtrz
    private static $test_mode = false;
    private static $test_interval = 600; // 10 minut dla test√≥w
    private static $production_interval = 86400; // 24 godziny dla produkcji
    
    /**
     * Singleton pattern
     */
    public static function get_instance() {
        if (self::$instance === null) {
            self::$instance = new self();
        }
        return self::$instance;
    }
    
    /**
     * Konstruktor
     */
    private function __construct() {
        // Hook dla wykonywania sprawdzania
        add_action(self::$hook_name, array($this, 'execute_widget_check'));
        
        // Hook dla sprawdzania harmonogramu (tylko raz dziennie)
        add_action('wp_loaded', array($this, 'maybe_update_schedule'), 10);
        
        // Dodaj w≈Çasny interwa≈Ç dla test√≥w
        add_filter('cron_schedules', array($this, 'add_custom_intervals'));
    }
    
    /**
     * Dodaje w≈Çasne interwa≈Çy cron
     */
    public function add_custom_intervals($schedules) {
        $schedules['ten_minutes'] = array(
            'interval' => 600, // 10 minut
            'display' => 'Co 10 minut (test)'
        );
        return $schedules;
    }
    
    /**
     * W≈ÇƒÖcza tryb testowy (sprawdzanie co 10 minut)
     */
    public static function enable_test_mode() {
        self::$test_mode = true;
        update_option('indexfixer_widget_test_mode', true);
        
        IndexFixer_Logger::log('üß™ TRYB TESTOWY W≈ÅƒÑCZONY - usuwam stary harmonogram', 'info');
        
        // Usu≈Ñ WSZYSTKIE crony z tym hookiem
        wp_clear_scheduled_hook(self::$hook_name);
        
        // Wyczy≈õƒá cache sprawdzania harmonogramu
        delete_option('indexfixer_widget_schedule_check');
        
        // Zaplanuj nowy z kr√≥tkim interwa≈Çem (10 minut)
        $scheduled = wp_schedule_event(time(), 'ten_minutes', self::$hook_name);
        
        if ($scheduled !== false) {
            $next_run = wp_next_scheduled(self::$hook_name);
            $next_run_local = date('Y-m-d H:i:s', $next_run + (get_option('gmt_offset') * 3600));
            IndexFixer_Logger::log("‚úÖ Zaplanowano nowy harmonogram TESTOWY (10 min) - nastƒôpne uruchomienie: $next_run_local", 'success');
        } else {
            IndexFixer_Logger::log('‚ùå Nie uda≈Ço siƒô zaplanowaƒá nowego harmonogramu testowego', 'error');
        }
    }
    
    /**
     * Wy≈ÇƒÖcza tryb testowy (powr√≥t do 24h)
     */
    public static function disable_test_mode() {
        self::$test_mode = false;
        update_option('indexfixer_widget_test_mode', false);
        
        IndexFixer_Logger::log('üèÅ TRYB TESTOWY WY≈ÅƒÑCZONY - usuwam stary harmonogram', 'info');
        
        // Usu≈Ñ WSZYSTKIE crony z tym hookiem (mo≈ºe byƒá kilka z r√≥≈ºnymi interwa≈Çami)
        wp_clear_scheduled_hook(self::$hook_name);
        
        // Wyczy≈õƒá cache sprawdzania harmonogramu ≈ºeby wymusiƒá ponowne planowanie
        delete_option('indexfixer_widget_schedule_check');
        
        // Sprawd≈∫ czy widgety sƒÖ aktywne
        $instance = self::get_instance();
        $widgets_active = $instance->are_widgets_active();
        
        if ($widgets_active) {
            // Zaplanuj nowy harmonogram w trybie produkcyjnym (24h)
            $scheduled = wp_schedule_event(time(), 'daily', self::$hook_name);
            
            if ($scheduled !== false) {
                $next_run = wp_next_scheduled(self::$hook_name);
                $next_run_local = date('Y-m-d H:i:s', $next_run + (get_option('gmt_offset') * 3600));
                IndexFixer_Logger::log("‚úÖ Zaplanowano nowy harmonogram PRODUKCYJNY (24h) - nastƒôpne uruchomienie: $next_run_local", 'success');
            } else {
                IndexFixer_Logger::log('‚ùå Nie uda≈Ço siƒô zaplanowaƒá nowego harmonogramu', 'error');
            }
        } else {
            IndexFixer_Logger::log('‚ÑπÔ∏è Brak aktywnych widget√≥w - nie planuje harmonogramu', 'info');
        }
    }
    
    /**
     * Sprawdza czy tryb testowy jest w≈ÇƒÖczony
     */
    public static function is_test_mode() {
        return get_option('indexfixer_widget_test_mode', false);
    }
    
    /**
     * Sprawdza czy trzeba zaktualizowaƒá harmonogram (wywo≈Çywane raz dziennie)
     */
    public function maybe_update_schedule() {
        // Sprawd≈∫ czy ju≈º sprawdzali≈õmy dzisiaj
        $last_check = get_option('indexfixer_widget_schedule_check', 0);
        $today = date('Y-m-d');
        $last_check_date = date('Y-m-d', $last_check);
        
        if ($last_check_date === $today) {
            return; // Ju≈º sprawdzali≈õmy dzisiaj
        }
        
        // Zapisz ≈ºe sprawdzili≈õmy dzisiaj
        update_option('indexfixer_widget_schedule_check', time());
        
        // Sprawd≈∫ czy jakikolwiek widget ma w≈ÇƒÖczone auto_check
        $widgets_active = $this->are_widgets_active();
        $scheduled = wp_next_scheduled(self::$hook_name);
        
        if ($widgets_active && !$scheduled) {
            // Zaplanuj sprawdzanie
            $interval = self::is_test_mode() ? 'ten_minutes' : 'daily';
            wp_schedule_event(time(), $interval, self::$hook_name);
            
            $mode = self::is_test_mode() ? 'TESTOWY (10 min)' : 'PRODUKCYJNY (24h)';
            IndexFixer_Logger::log("üìÖ Zaplanowano automatyczne sprawdzanie widget√≥w - tryb: $mode", 'info');
            
        } elseif (!$widgets_active && $scheduled) {
            // Usu≈Ñ harmonogram
            wp_clear_scheduled_hook(self::$hook_name);
            IndexFixer_Logger::log('üóëÔ∏è Usuniƒôto automatyczne sprawdzanie widget√≥w - brak aktywnych widget√≥w', 'info');
        }
    }
    
    /**
     * Sprawdza czy jakikolwiek widget ma w≈ÇƒÖczone auto_check
     * @return bool True je≈õli znaleziono aktywne widgety
     */
    public function are_widgets_active() {
        $force_active = apply_filters('indexfixer_force_widgets_active', false);
        if ($force_active === true) {
            IndexFixer_Logger::log("üîß Aktywno≈õƒá widget√≥w wymuszona przez filtr", 'info');
            return true;
        }
        // Sprawd≈∫ klasyczne widgety
        $widget_instances = get_option('widget_indexfixer_not_indexed', array());
        $active_instance_found = false;
        foreach ($widget_instances as $key => $instance) {
            if (is_numeric($key) && is_array($instance) && !empty($instance)) {
                IndexFixer_Logger::log("üìä Znaleziono instancjƒô widgetu #{$key}", 'debug');
                if (!empty($instance['auto_check'])) {
                    IndexFixer_Logger::log("‚úÖ Znaleziono aktywny widget #{$key} z w≈ÇƒÖczonym auto_check", 'info');
                    $active_instance_found = true;
                    break;
                }
            }
        }
        if ($active_instance_found) {
            return true;
        }
        // NOWO≈öƒÜ: Wykrywanie blok√≥w IndexFixer w sidebarach (Gutenberg)
        $sidebars_widgets = get_option('sidebars_widgets', array());
        foreach ($sidebars_widgets as $sidebar_id => $widgets) {
            if (!is_array($widgets)) continue;
            foreach ($widgets as $widget_id) {
                // Sprawd≈∫ czy to blok IndexFixer (np. block-2, block-3...)
                if (strpos($widget_id, 'block-') === 0) {
                    // Pobierz zawarto≈õƒá bloku z bazy danych
                    global $wpdb;
                    $post = $wpdb->get_row($wpdb->prepare(
                        "SELECT post_content FROM {$wpdb->posts} WHERE ID = %d AND post_status = 'publish'",
                        (int)str_replace('block-', '', $widget_id)
                    ));
                    if ($post && strpos($post->post_content, 'wp:indexfixer/not-indexed-posts') !== false) {
                        IndexFixer_Logger::log("üü© Znaleziono blok IndexFixer w sidebarze '{$sidebar_id}' (ID: {$widget_id})", 'info');
                        return true;
                    }
                }
            }
        }
        // Sprawd≈∫ bloki IndexFixer w postach/stronach (jak dotychczas)
        global $wpdb;
        $block_usage = $wpdb->get_var(
            "SELECT COUNT(*) FROM {$wpdb->posts} 
             WHERE post_content LIKE '%wp:indexfixer/not-indexed-posts%' 
             AND post_status = 'publish'"
        );
        if ($block_usage > 0) {
            IndexFixer_Logger::log("‚úÖ Znaleziono {$block_usage} blok√≥w Gutenberga", 'info');
            return true;
        }
        IndexFixer_Logger::log("‚ùå Nie znaleziono aktywnych widget√≥w ani blok√≥w", 'warning');
        return false;
    }
    
    /**
     * Wykonuje sprawdzanie URL-i dla widget√≥w
     */
    public function execute_widget_check() {
        $mode = self::is_test_mode() ? 'TESTOWY' : 'PRODUKCYJNY';
        IndexFixer_Logger::log("ü§ñ ROZPOCZƒòCIE AUTOMATYCZNEGO SPRAWDZANIA WIDGET√ìW - tryb: $mode", 'info');
        
        // Sprawd≈∫ czy widgety sƒÖ nadal aktywne
        if (!$this->are_widgets_active()) {
            IndexFixer_Logger::log('‚ö†Ô∏è Brak aktywnych widget√≥w - ko≈Ñczƒô sprawdzanie', 'warning');
            wp_clear_scheduled_hook(self::$hook_name);
            return;
        }
        
        // Pobierz URL-e do sprawdzenia
        $limit = self::is_test_mode() ? 5 : 10; // Mniej URL-i w trybie testowym
        $urls_to_check = $this->get_actual_widget_urls($limit);
        
        if (empty($urls_to_check)) {
            IndexFixer_Logger::log('‚ÑπÔ∏è Brak URL-√≥w do sprawdzenia przez widgety', 'info');
            return;
        }
        
        IndexFixer_Logger::log("üéØ Znaleziono " . count($urls_to_check) . " URL-√≥w do sprawdzenia", 'info');
        
        $gsc_api = new IndexFixer_GSC_API();
        $checked = 0;
        $indexed_found = 0;
        
        foreach ($urls_to_check as $url_data) {
            IndexFixer_Logger::log("üîç Sprawdzam: {$url_data->url}", 'info');
            
            try {
                $status = $gsc_api->check_url_status($url_data->url);
                
                if ($status && !isset($status['error'])) {
                    // Przygotuj dane w ujednoliconym formacie
                    $detailed_status = array(
                        'verdict' => isset($status['indexStatusResult']['verdict']) ? $status['indexStatusResult']['verdict'] : 'unknown',
                        'coverageState' => isset($status['indexStatusResult']['coverageState']) ? $status['indexStatusResult']['coverageState'] : 'unknown',
                        'robotsTxtState' => isset($status['indexStatusResult']['robotsTxtState']) ? $status['indexStatusResult']['robotsTxtState'] : 'unknown',
                        'indexingState' => isset($status['indexStatusResult']['indexingState']) ? $status['indexStatusResult']['indexingState'] : 'unknown',
                        'pageFetchState' => isset($status['indexStatusResult']['pageFetchState']) ? $status['indexStatusResult']['pageFetchState'] : 'unknown',
                        'lastCrawlTime' => isset($status['indexStatusResult']['lastCrawlTime']) ? $status['indexStatusResult']['lastCrawlTime'] : 'unknown',
                        'crawledAs' => isset($status['indexStatusResult']['crawledAs']) ? $status['indexStatusResult']['crawledAs'] : 'unknown'
                    );
                    
                    // Dodaj prosty status
                    if (isset($status['indexStatusResult']['coverageState'])) {
                        $coverage_state = $status['indexStatusResult']['coverageState'];
                        switch($coverage_state) {
                            case 'Submitted and indexed':
                                $detailed_status['simple_status'] = 'INDEXED';
                                $indexed_found++;
                                IndexFixer_Logger::log("üéâ ZAINDEKSOWANO: {$url_data->url}", 'success');
                                break;
                            case 'Crawled - currently not indexed':
                                $detailed_status['simple_status'] = 'NOT_INDEXED';
                                IndexFixer_Logger::log("‚è≥ Nadal nie zaindeksowane: {$url_data->url}", 'info');
                                break;
                            case 'Discovered - currently not indexed':
                                $detailed_status['simple_status'] = 'PENDING';
                                IndexFixer_Logger::log("üîç Odkryte ale nie zaindeksowane: {$url_data->url}", 'info');
                                break;
                            default:
                                $detailed_status['simple_status'] = 'OTHER';
                                IndexFixer_Logger::log("‚ùì Inny status: {$url_data->url} - {$coverage_state}", 'info');
                        }
                    } else {
                        $detailed_status['simple_status'] = 'unknown';
                    }
                    
                    // Zapisz w bazie danych
                    IndexFixer_Database::save_url_status($url_data->post_id, $url_data->url, $detailed_status);
                    $checked++;
                    
                    // Rate limiting
                    sleep(2);
                    
                } else {
                    IndexFixer_Logger::log("‚ùå B≈ÇƒÖd sprawdzania: {$url_data->url}", 'error');
                }
                
            } catch (Exception $e) {
                IndexFixer_Logger::log("üí• WyjƒÖtek przy sprawdzaniu {$url_data->url}: {$e->getMessage()}", 'error');
            }
        }
        
        IndexFixer_Logger::log("üèÅ ZAKO≈ÉCZENIE SPRAWDZANIA WIDGET√ìW:", 'info');
        IndexFixer_Logger::log("   ‚Ä¢ Sprawdzono: $checked URL-√≥w", 'info');
        IndexFixer_Logger::log("   ‚Ä¢ Nowo zaindeksowane: $indexed_found URL-√≥w", 'success');
        
        if ($indexed_found > 0) {
            IndexFixer_Logger::log("üéä Gratulacje! $indexed_found URL-√≥w zosta≈Ço zaindeksowanych!", 'success');
        }
    }
    
    /**
     * Rƒôczne uruchomienie sprawdzania (dla test√≥w)
     */
    public static function run_manual_check() {
        $instance = self::get_instance();
        $instance->execute_widget_check();
    }
    
    /**
     * Pobiera status harmonogramu
     */
    public static function get_schedule_status() {
        $scheduled = wp_next_scheduled(self::$hook_name);
        $test_mode = self::is_test_mode();
        
        return array(
            'scheduled' => $scheduled,
            'next_run' => $scheduled ? date('Y-m-d H:i:s', $scheduled) : null,
            'test_mode' => $test_mode,
            'interval' => $test_mode ? '10 minut' : '24 godziny'
        );
    }
    
    /**
     * Cleanup przy deaktywacji wtyczki
     */
    public static function cleanup() {
        wp_clear_scheduled_hook(self::$hook_name);
        delete_option('indexfixer_widget_test_mode');
        delete_option('indexfixer_widget_schedule_check');
    }
    
    /**
     * NOWA: Pobiera dok≈Çadnie te URL-e kt√≥re sƒÖ wy≈õwietlane w aktywnych widgetach
     */
    private function get_actual_widget_urls($max_limit = 10) {
        $all_widget_urls = array();
        
        // 1. Pobierz URL-e z widget WordPress
        $widget_instances = get_option('widget_indexfixer_not_indexed', array());
        foreach ($widget_instances as $instance) {
            if (!empty($instance['auto_check'])) {
                $count = !empty($instance['count']) ? (int) $instance['count'] : 5;
                $widget_urls = IndexFixer_Database::get_urls_by_status('not_indexed', $count);
                foreach ($widget_urls as $url_data) {
                    // Dodajemy logikƒô widget_since
                    if (empty($url_data->widget_since)) {
                        // Ustaw widget_since na dzi≈õ je≈õli nie by≈Ço
                        IndexFixer_Database::save_url_status($url_data->post_id, $url_data->url, array_merge((array)$url_data, ['widget_since' => current_time('mysql')]));
                        $url_data->widget_since = current_time('mysql');
                    }
                    $all_widget_urls[$url_data->url] = $url_data; // U≈ºyj URL jako klucz ≈ºeby uniknƒÖƒá duplikat√≥w
                }
            }
        }
        
        // 2. Pobierz URL-e z blok widget (sprawd≈∫ wszystkie posty/strony z blokiem)
        global $wpdb;
        $posts_with_blocks = $wpdb->get_results(
            "SELECT post_content FROM {$wpdb->posts} 
             WHERE post_content LIKE '%wp:indexfixer/not-indexed-posts%' 
             AND post_status = 'publish'"
        );
        
        foreach ($posts_with_blocks as $post) {
            // Parsuj blok ≈ºeby wyciƒÖgnƒÖƒá parametr count
            preg_match('/wp:indexfixer\\/not-indexed-posts\\s*({[^}]*})?/', $post->post_content, $matches);
            $count = 5; // Domy≈õlna warto≈õƒá
            if (!empty($matches[1])) {
                $block_attrs = json_decode($matches[1], true);
                if (isset($block_attrs['count'])) {
                    $count = (int) $block_attrs['count'];
                }
            }
            $block_urls = IndexFixer_Database::get_urls_by_status('not_indexed', $count);
            foreach ($block_urls as $url_data) {
                if (!isset($all_widget_urls[$url_data->url])) { // Tylko je≈õli jeszcze nie ma
                    // Dodajemy logikƒô widget_since
                    if (empty($url_data->widget_since)) {
                        IndexFixer_Database::save_url_status($url_data->post_id, $url_data->url, array_merge((array)$url_data, ['widget_since' => current_time('mysql')]));
                        $url_data->widget_since = current_time('mysql');
                    }
                    $url_data->widget_source = 'Blok w: ' . $post->post_title;
                    $url_data->widget_count = $count;
                    $all_widget_urls[$url_data->url] = $url_data;
                }
            }
        }
        
        // 3. Filtruj tylko te kt√≥re wymagajƒÖ sprawdzenia (nie by≈Çy sprawdzane przez 24h)
        $urls_to_check = array();
        foreach ($all_widget_urls as $url_data) {
            // Sprawd≈∫ czy URL wymaga sprawdzenia
            if (empty($url_data->last_checked) || 
                strtotime($url_data->last_checked) < (time() - 24 * 3600)) {
                $urls_to_check[] = $url_data;
                
                if (count($urls_to_check) >= $max_limit) {
                    break; // Ogranicz do max_limit
                }
            }
        }
        
        IndexFixer_Logger::log("üéØ Znaleziono " . count($all_widget_urls) . " unikalnych URL-√≥w w widgetach, " . count($urls_to_check) . " wymaga sprawdzenia", 'info');
        
        return $urls_to_check;
    }
    
    /**
     * PUBLICZNA: Pobiera wszystkie URL-e wy≈õwietlane w aktywnych widgetach (dla dashboardu)
     */
    public static function get_all_widget_urls() {
        $all_widget_urls = array();
        
        // Debugowanie
        error_log('IndexFixer: get_all_widget_urls() - START');
        
        // 1. Pobierz URL-e z widget WordPress
        $widget_instances = get_option('widget_indexfixer_not_indexed', array());
        error_log('IndexFixer: Znaleziono ' . count($widget_instances) . ' instancji WordPress widget');
        error_log('IndexFixer: Raw widget_instances: ' . print_r($widget_instances, true));
        
        foreach ($widget_instances as $key => $instance) {
            error_log("IndexFixer: Sprawdzam instancjƒô #{$key}: " . print_r($instance, true));
            
            if (!empty($instance['auto_check'])) {
                $count = !empty($instance['count']) ? (int) $instance['count'] : 5;
                // Zwiƒôksz limit je≈õli widget ma wiƒôcej ni≈º 10 URL-√≥w
                $actual_limit = max($count, 15); // Minimum 15 URL-√≥w
                $post_type = !empty($instance['post_type']) ? $instance['post_type'] : 'post';
                error_log("IndexFixer: WordPress widget #{$key} - count: $count, actual_limit: $actual_limit, post_type: $post_type, auto_check: w≈ÇƒÖczone");
                
                $widget_urls = IndexFixer_Database::get_urls_by_status_and_type('not_indexed', $post_type, $actual_limit);
                error_log('IndexFixer: WordPress widget #{$key} zwr√≥ci≈Ç ' . count($widget_urls) . ' URL-√≥w (limit: ' . $actual_limit . ')');
                
                $added_count = 0;
                foreach ($widget_urls as $url_data) {
                    if (!isset($all_widget_urls[$url_data->url])) { // Tylko je≈õli jeszcze nie ma
                        $url_data->widget_source = 'WordPress Widget #' . $key . ' (' . $post_type . ')';
                        $url_data->widget_count = $count;
                        $url_data->widget_post_type = $post_type;
                        $all_widget_urls[$url_data->url] = $url_data;
                        $added_count++;
                        error_log("IndexFixer: Dodano URL z widget #{$key}: {$url_data->url}");
                    } else {
                        error_log("IndexFixer: Pominiƒôto duplikat URL z widget #{$key}: {$url_data->url}");
                    }
                }
                error_log("IndexFixer: Widget #{$key} doda≈Ç {$added_count} nowych URL-√≥w (z {$count} pobranych)");
            } else {
                error_log("IndexFixer: WordPress widget #{$key} - auto_check: WY≈ÅƒÑCZONE");
            }
        }
        
        // 2. Pobierz URL-e z blok widget (sprawd≈∫ wszystkie posty/strony z blokiem)
        global $wpdb;
        $posts_with_blocks = $wpdb->get_results(
            "SELECT ID, post_title, post_content FROM {$wpdb->posts} 
             WHERE post_content LIKE '%wp:indexfixer/not-indexed-posts%' 
             AND post_status = 'publish'"
        );
        
        error_log('IndexFixer: Znaleziono ' . count($posts_with_blocks) . ' post√≥w z blokami');
        
        foreach ($posts_with_blocks as $post) {
            // Parsuj blok ≈ºeby wyciƒÖgnƒÖƒá parametr count i post_type
            preg_match('/wp:indexfixer\\/not-indexed-posts\\s*({[^}]*})?/', $post->post_content, $matches);
            $count = 5; // Domy≈õlna warto≈õƒá
            $post_type = 'post';
            if (!empty($matches[1])) {
                $block_attrs = json_decode($matches[1], true);
                if (isset($block_attrs['count'])) {
                    $count = (int) $block_attrs['count'];
                }
                if (isset($block_attrs['postType'])) {
                    $post_type = sanitize_text_field($block_attrs['postType']);
                }
            }
            
            error_log("IndexFixer: Blok w '{$post->post_title}' - count: $count, post_type: $post_type");
            
            $block_urls = IndexFixer_Database::get_urls_by_status_and_type('not_indexed', $post_type, $count);
            error_log('IndexFixer: Blok zwr√≥ci≈Ç ' . count($block_urls) . ' URL-√≥w');
            
            foreach ($block_urls as $url_data) {
                if (!isset($all_widget_urls[$url_data->url])) { // Tylko je≈õli jeszcze nie ma
                    $url_data->widget_source = 'Blok w: ' . $post->post_title . ' (' . $post_type . ')';
                    $url_data->widget_count = $count;
                    $url_data->widget_post_type = $post_type;
                    $all_widget_urls[$url_data->url] = $url_data;
                }
            }
        }
        
        error_log('IndexFixer: get_all_widget_urls() - KONIEC, zwracam ' . count($all_widget_urls) . ' URL-√≥w');
        
        return array_values($all_widget_urls); // Zwr√≥ƒá jako zwyk≈ÇƒÖ tablicƒô
    }
    
    /**
     * Zwraca raport diagnostyczny o widgetach
     * @return array Szczeg√≥≈Çowe informacje o stanie widget√≥w
     */
    public static function get_widget_diagnostic_report() {
        global $wpdb;
        $instance = self::get_instance();
        $report = array();
        
        // 1. Sprawd≈∫ opcjƒô widget_indexfixer_not_indexed
        $widget_instances = get_option('widget_indexfixer_not_indexed', array());
        $active_instances = array();
        
        foreach ($widget_instances as $key => $instance_data) {
            if (is_numeric($key) && !empty($instance_data)) {
                $active_instances[$key] = $instance_data;
            }
        }
        
        $report['widget_option'] = array(
            'raw_data' => $widget_instances,
            'active_instances' => $active_instances,
            'count' => count($active_instances)
        );
        
        // 2. Sprawd≈∫ sidebars_widgets
        $sidebars_widgets = get_option('sidebars_widgets', array());
        $found_in_sidebars = array();
        
        foreach ($sidebars_widgets as $sidebar_id => $widgets) {
            if (!is_array($widgets)) continue;
            
            foreach ($widgets as $widget_id) {
                if (strpos($widget_id, 'indexfixer_not_indexed-') === 0) {
                    $id_parts = explode('-', $widget_id);
                    $instance_id = isset($id_parts[1]) ? (int)$id_parts[1] : 0;
                    $found_in_sidebars[] = array(
                        'sidebar_id' => $sidebar_id,
                        'widget_id' => $widget_id,
                        'instance_id' => $instance_id
                    );
                }
            }
        }
        
        $report['sidebars'] = array(
            'found_instances' => $found_in_sidebars,
            'count' => count($found_in_sidebars)
        );
        
        // 3. Sprawd≈∫ bloki Gutenberga
        $block_usage = $wpdb->get_var(
            "SELECT COUNT(*) FROM {$wpdb->posts} 
             WHERE post_content LIKE '%wp:indexfixer/not-indexed-posts%' 
             AND post_status = 'publish'"
        );
        
        $report['gutenberg_blocks'] = array(
            'count' => (int)$block_usage,
            'query_result' => $block_usage
        );
        
        // 4. Sprawd≈∫ wynik funkcji are_widgets_active
        $is_active = $instance->are_widgets_active();
        $force_active = apply_filters('indexfixer_force_widgets_active', false);
        
        $report['status'] = array(
            'is_active' => $is_active,
            'force_active' => $force_active,
            'hook_name' => self::$hook_name,
            'next_scheduled' => wp_next_scheduled(self::$hook_name)
        );
        
        return $report;
    }
}

// Inicjalizuj scheduler
IndexFixer_Widget_Scheduler::get_instance(); 